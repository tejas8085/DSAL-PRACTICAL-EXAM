/*

Consider telephone book database of N clients. Make use of a hash table implementation
to quickly look up clientâ€˜s telephone number. Make use of two collision handling
techniques and compare them using number of comparisons required to find a set of
telephone numbers

                        QUESTIONS

1.  Hashing ---> Hashing in the data structure is a technique of mapping a large chunk of data into small tables using a hashing function. It is also known as the message digest function. It is a technique that uniquely identifies a specific item from a collection of similar items.

2. Hash Table ---> Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.

3.  Collision Handling Techniques 
   i) Open Hashing (separate Chaining)
   ii) Closed Hasing (open Addessing)
      	a) Liner Probing
		b) Quadratic probing
		c) Double hashing

4  What is Collison ?
  A collision occurs when more than one value to be hashed by a particular hash function hash to the same slot in the table or data structure (hash table) being generated by the hash function.

5. Separate Chaining --->
  The idea is to make each cell of hash table point to a linked list of records that have same hash function value. 

*/



// **************   SEPARATE CHANING    ********************





#include <iostream>
using namespace std;

struct node{
	long long int telephone;
	node *next;
};

class sepratechaining{
	public:
	node *ht[10];
	sepratechaining(){
		for(int i=0;i<10;i++){
			ht[i]=NULL;
			
		}
	}
	
	void insert(long long int key){
		int a=key%10;
		node *p=new node;
		p->telephone=key;
		p->next=NULL;
		if(ht[a]==NULL){
			ht[a]=p;
		}
		else{
			node *q=ht[a];
			while(q->next!=NULL){
				q=q->next;
			}
			q->next=p;
			
		}
	}
	
	void display(){
		for(int i=0;i<10;i++){
			node *p;
			p=ht[i];
			if(p==NULL){
				cout<<i<<"\t-\n";
			}
			else{
				while(p!=NULL){
				
				cout<<i<<"\t"<<p->telephone;
				p=p->next;
			}
				cout<<"\n";
			}
			
		}
	}
	
	void search(long long int key){
		int loc=key%10;
		int com=0;
		int flag=0;
		node *p=ht[loc];
		while(p->telephone!=key){
			com=com+1;
			p=p->next;
		}
		cout<<"element found at- "<<p<<" address in "<<com+1<<" comparisons\n";
}
	
};

int main(){
	sepratechaining h;
	long long int choice,v;
	while(choice!=4){
	
		cout<<"1.insert\n2.display\n3.search\n4.exit\n";
		cin>>choice;
		switch(choice){
			case 1:
				cout<<"element to insert-: ";
				cin>>v;
				h.insert(v);
				break;
			
			case 2:
				h.display();
				break;
			case 3:
				cout<<"element to search: ";
				cin>>v;
				h.search(v);
				break;
			case 4:
				break;
			
			default:
				cout<<"wrong input";
				
		}
	}
	return 0;
}
